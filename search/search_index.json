{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview In this workshop, you learn how to build a serverless customer-facing microservices application demonstrating end-to-end authentication and authorization using Amazon Cognito, Amazon API Gateway, AWS Lambda, and all things AWS Identity and Access Management (IAM). You have the opportunity to build an end-to-end functional app with a secure identity provider showcasing user authentication patterns. Level : Advanced Duration : 2 hours CSF Functions : Prevent CAF Components : Preventative Prerequisites : AWS Account, Admin IAM User AWS Services : Amazon Cognito , Amazon API Gateway , AWS Lambda , AWS IAM Architecture The microservices application you'll be building enables users to request unicorn rides from the Wild Rydes fleet. The application will present users with a user interface for signing-up, signing-in, indicating their location to request a ride, and managing their rider profile. The application architecture demonstrates end-to-end authentication and authorization patterns through the use of Amazon Cognito , Amazon API Gateway , AWS Lambda , and AWS IAM . A single page React JS web app hosts the HTML, CSS, and JavaScript to render the front-end which then connects to a public serverless backend API built using Amazon API Gateway and AWS Lambda. Amazon Cognito provides user identity management and authentication functions to secure the backend API. Finally, DynamoDB provides a persistence layer where data is stored and retrieved via the API's Lambda function. See the diagram below for a depiction of the complete architecture. Modules This workshop is split into multiple modules. Each module builds upon the previous module as you expand the Wild Rydes application. You must complete each module before proceeding to the next. User Authentication - In this module, you will create a Cognito User Pool for identity management and user authentication and will integrate it with a pre-existing WildRydes React JS Web Application. You will also configure Cognito Identity Pools, which provides the ability to assume an Identity and Access Management (IAM) role from within an application. Backend authorization - In this module, you will add a serverless backend to our Wild Rydes application leveraging API Gateway and Lambda. You will then enable authentication and authorization on your API to secure the backend to only accept valid, authorized requests. IAM Authorization - In this module, you will expand your Wild Rydes application by enabling profile management and profile photo management capabilities. Amazon Cognito will be used to store your user's profile information and attributes whereas Amazon S3 will store your user's profile pictures, with a link to the photo stored in the user's profile information. Cleanup - To prevent your account from accruing additional charges, you'll go through and cleanup all the resources you've used for this workshop. Proceed to the next module to setup your environment.","title":"Overview"},{"location":"#overview","text":"In this workshop, you learn how to build a serverless customer-facing microservices application demonstrating end-to-end authentication and authorization using Amazon Cognito, Amazon API Gateway, AWS Lambda, and all things AWS Identity and Access Management (IAM). You have the opportunity to build an end-to-end functional app with a secure identity provider showcasing user authentication patterns. Level : Advanced Duration : 2 hours CSF Functions : Prevent CAF Components : Preventative Prerequisites : AWS Account, Admin IAM User AWS Services : Amazon Cognito , Amazon API Gateway , AWS Lambda , AWS IAM","title":"Overview"},{"location":"#architecture","text":"The microservices application you'll be building enables users to request unicorn rides from the Wild Rydes fleet. The application will present users with a user interface for signing-up, signing-in, indicating their location to request a ride, and managing their rider profile. The application architecture demonstrates end-to-end authentication and authorization patterns through the use of Amazon Cognito , Amazon API Gateway , AWS Lambda , and AWS IAM . A single page React JS web app hosts the HTML, CSS, and JavaScript to render the front-end which then connects to a public serverless backend API built using Amazon API Gateway and AWS Lambda. Amazon Cognito provides user identity management and authentication functions to secure the backend API. Finally, DynamoDB provides a persistence layer where data is stored and retrieved via the API's Lambda function. See the diagram below for a depiction of the complete architecture.","title":"Architecture"},{"location":"#modules","text":"This workshop is split into multiple modules. Each module builds upon the previous module as you expand the Wild Rydes application. You must complete each module before proceeding to the next. User Authentication - In this module, you will create a Cognito User Pool for identity management and user authentication and will integrate it with a pre-existing WildRydes React JS Web Application. You will also configure Cognito Identity Pools, which provides the ability to assume an Identity and Access Management (IAM) role from within an application. Backend authorization - In this module, you will add a serverless backend to our Wild Rydes application leveraging API Gateway and Lambda. You will then enable authentication and authorization on your API to secure the backend to only accept valid, authorized requests. IAM Authorization - In this module, you will expand your Wild Rydes application by enabling profile management and profile photo management capabilities. Amazon Cognito will be used to store your user's profile information and attributes whereas Amazon S3 will store your user's profile pictures, with a link to the photo stored in the user's profile information. Cleanup - To prevent your account from accruing additional charges, you'll go through and cleanup all the resources you've used for this workshop. Proceed to the next module to setup your environment.","title":"Modules"},{"location":"00-env-setup/","text":"Module 0 Environment setup Time : 10 minutes This section outlines the prerequisites to complete the workshop and instructions for launching a Cloud9 IDE environment that you will use throughout the workshop. Setup your Cloud9 IDE To setup your environment please expand one of the following dropdown sections (depending on how you're doing this workshop) and follow the instructions: Click here if you're at an AWS event where Event Engine is being used Navigate to the Event Engine dashboard Enter the team hash code that was distributed to you by the instructors. Click AWS Console . The CloudFormation template for this round has already been prerun. Click here if you're running this individually in your own AWS Account Cloud9 IDE Setup In this section you will launch a CloudFormation stack that will create a a new Amazon VPC environment and a Cloud9 IDE Instance that you will use for the rest of the workshop. Region Deploy us-east-1 (N. Virginia) us-east-2 (Ohio) us-west-2 (Oregon) Click the Deploy to AWS button above. This will automatically take you to the console to run the template. The Specify an Amazon S3 template URL is already selected and the template URL is automatically added. Click Next . On the Specify Details click Next (leave defaults). On the Options click Next (leave everything on this page as the default). On the Review page, review the summary details, click the checkbox to acknowledge IAM capabilities , and then click Create stack . It will take a few minutes for the Stack to create. Choose the Stack Info tab to go to the overall stack status page and wait until the stack is fully launched and shows a status of CREATE_COMPLETE . Click the refresh icon periodically to see progress update. CloudFormation deploys a nested CloudFormation stack to launch the Cloud9 resources. You can safely ignore the template which is prefixed with aws-cloud9-WildRydes- . Browse to your Cloud9 IDE AWS Cloud9 is a cloud-based integrated development environment (IDE) that lets you write, run, and debug your code with just a browser. It includes a code editor, debugger, and terminal. Cloud9 comes pre-packaged with essential tools for popular programming languages and the AWS Command Line Interface (CLI) pre-installed so you don\u2019t need to install files or configure your laptop for this workshop. With the serverless-idm-cloud9 stack selected, click on the Outputs tab and copy the value shown for the Cloud9IDE to the clipboard. Browse to that URL in a new browser tab to load your IDE environment. Once you have launched and navigated to your Cloud9 workspace URL shown in your CloudFormation stack outputs, you should have an IDE environment as shown below: You can run AWS CLI commands in here just like you would on your local computer. Verify that your user is logged in by running the following: aws sts get-caller-identity You should see output, similar to the code below, indicating your account and user information: EXAMPLE OUTPUT - DO NOT COPY { Account : 123456789012 , UserId : AKIAI44QH8DHBEXAMPLE , Arn : arn:aws:iam::123456789012:user/Sasquatch } Keep your AWS Cloud9 IDE opened in a tab throughout this workshop as you'll be using it for most all activities. Download Workshop Code Switch to the tab where you have your Cloud9 IDE opened. Clone the workshop repository to your IDE environment by running the following command in the Cloud9 terminal window: git clone https://github.com/aws-samples/amazon-cognito-identity-management-workshop.git Initialize your developer workspace Run the following commands to upgrade your Node.js version to the latest version of Node.js 8. The AWS Amplify JavaScript library which we will be using requires Node.js 8 or higher. nvm i 8 nvm alias default 8 Install the yarn package manager and website dependencies by running the following commands npm install -g yarn cd ~/environment/amazon-cognito-identity-management-workshop/website/ yarn install Keep a scratch pad for notes Keep a scratch pad in Cloud9 or a text editor on your local computer for notes. When the step-by-step directions tell you to note something such as an ID or Amazon Resource Name (ARN), copy and paste that into the scratch pad tab. Within Cloud9, click the + symbol and choose to create New File . You will use this new blank editor tab as a scratchpad for various resource names and variables. Run the website locally Run the following command to start the local web server yarn start Wait for the development server to start. You can ignore any message saying Compiled with warnings as we will resolve these warnings as we add our functionality to the application. Now that the development server has started, click Preview Running Application in the top of the screen next to the Run button. The web application will load in a small window next to the terminal at the bottom of the Cloud9 IDE. Click the re-size button next to the word Browser to open this window in a new tab. As you make changes to the web application, this tab will automatically refresh to reflect your changes. Leave this tab open and return to the Cloud9 IDE tab to continue the workshop. Though the Wild Rydes website may look functional, there is currently no integration for sign-up or sign-in requests to go anywhere. After you have successfully setup your environment, you can proceed to the next module.","title":"Module 0: Environment setup"},{"location":"00-env-setup/#module-0-environment-setup","text":"Time : 10 minutes This section outlines the prerequisites to complete the workshop and instructions for launching a Cloud9 IDE environment that you will use throughout the workshop.","title":"Module 0 Environment setup"},{"location":"00-env-setup/#setup-your-cloud9-ide","text":"To setup your environment please expand one of the following dropdown sections (depending on how you're doing this workshop) and follow the instructions: Click here if you're at an AWS event where Event Engine is being used Navigate to the Event Engine dashboard Enter the team hash code that was distributed to you by the instructors. Click AWS Console . The CloudFormation template for this round has already been prerun. Click here if you're running this individually in your own AWS Account Cloud9 IDE Setup In this section you will launch a CloudFormation stack that will create a a new Amazon VPC environment and a Cloud9 IDE Instance that you will use for the rest of the workshop. Region Deploy us-east-1 (N. Virginia) us-east-2 (Ohio) us-west-2 (Oregon) Click the Deploy to AWS button above. This will automatically take you to the console to run the template. The Specify an Amazon S3 template URL is already selected and the template URL is automatically added. Click Next . On the Specify Details click Next (leave defaults). On the Options click Next (leave everything on this page as the default). On the Review page, review the summary details, click the checkbox to acknowledge IAM capabilities , and then click Create stack . It will take a few minutes for the Stack to create. Choose the Stack Info tab to go to the overall stack status page and wait until the stack is fully launched and shows a status of CREATE_COMPLETE . Click the refresh icon periodically to see progress update. CloudFormation deploys a nested CloudFormation stack to launch the Cloud9 resources. You can safely ignore the template which is prefixed with aws-cloud9-WildRydes- .","title":"Setup your Cloud9 IDE"},{"location":"00-env-setup/#browse-to-your-cloud9-ide","text":"AWS Cloud9 is a cloud-based integrated development environment (IDE) that lets you write, run, and debug your code with just a browser. It includes a code editor, debugger, and terminal. Cloud9 comes pre-packaged with essential tools for popular programming languages and the AWS Command Line Interface (CLI) pre-installed so you don\u2019t need to install files or configure your laptop for this workshop. With the serverless-idm-cloud9 stack selected, click on the Outputs tab and copy the value shown for the Cloud9IDE to the clipboard. Browse to that URL in a new browser tab to load your IDE environment. Once you have launched and navigated to your Cloud9 workspace URL shown in your CloudFormation stack outputs, you should have an IDE environment as shown below: You can run AWS CLI commands in here just like you would on your local computer. Verify that your user is logged in by running the following: aws sts get-caller-identity You should see output, similar to the code below, indicating your account and user information: EXAMPLE OUTPUT - DO NOT COPY { Account : 123456789012 , UserId : AKIAI44QH8DHBEXAMPLE , Arn : arn:aws:iam::123456789012:user/Sasquatch } Keep your AWS Cloud9 IDE opened in a tab throughout this workshop as you'll be using it for most all activities.","title":"Browse to your Cloud9 IDE"},{"location":"00-env-setup/#download-workshop-code","text":"Switch to the tab where you have your Cloud9 IDE opened. Clone the workshop repository to your IDE environment by running the following command in the Cloud9 terminal window: git clone https://github.com/aws-samples/amazon-cognito-identity-management-workshop.git","title":"Download Workshop Code"},{"location":"00-env-setup/#initialize-your-developer-workspace","text":"Run the following commands to upgrade your Node.js version to the latest version of Node.js 8. The AWS Amplify JavaScript library which we will be using requires Node.js 8 or higher. nvm i 8 nvm alias default 8 Install the yarn package manager and website dependencies by running the following commands npm install -g yarn cd ~/environment/amazon-cognito-identity-management-workshop/website/ yarn install Keep a scratch pad for notes Keep a scratch pad in Cloud9 or a text editor on your local computer for notes. When the step-by-step directions tell you to note something such as an ID or Amazon Resource Name (ARN), copy and paste that into the scratch pad tab. Within Cloud9, click the + symbol and choose to create New File . You will use this new blank editor tab as a scratchpad for various resource names and variables.","title":"Initialize your developer workspace"},{"location":"00-env-setup/#run-the-website-locally","text":"Run the following command to start the local web server yarn start Wait for the development server to start. You can ignore any message saying Compiled with warnings as we will resolve these warnings as we add our functionality to the application. Now that the development server has started, click Preview Running Application in the top of the screen next to the Run button. The web application will load in a small window next to the terminal at the bottom of the Cloud9 IDE. Click the re-size button next to the word Browser to open this window in a new tab. As you make changes to the web application, this tab will automatically refresh to reflect your changes. Leave this tab open and return to the Cloud9 IDE tab to continue the workshop. Though the Wild Rydes website may look functional, there is currently no integration for sign-up or sign-in requests to go anywhere. After you have successfully setup your environment, you can proceed to the next module.","title":"Run the website locally"},{"location":"01-user-auth/","text":"Module 1 User signup and authentication Time : 45 minutes In this module, you will create an Amazon Cognito User Pool and Identity Pool for the Wild Rydes application. The Cognito User Pool will store user profile information and provide sign-up and sign-in capabilities, with the Cognito Identity Pool providing the ability to assume an Identity and Access Management (IAM) role from within the application. Since Wild Rydes is a ride sharing application, a key requirement is that all users must sign-up and sign-in before they're allowed to request a ride. You will configure the application to integrate with Amazon Cognito for these purposes via the AWS Amplify JavaScript library. Architecture The architecture for this module is very straightforward. All of your static web content including HTML, CSS JavaScript, images and other files will be served locally from your Cloud9 workspace. As you make changes to the website application code, all changes will be automatically updated and shown in your browser via live reload capabilities. For this module, we will be creating a Cognito User Pool as our secure user directory then configuring our application to use the AWS Amplify library to easily integrate Amazon Cognito into our application. Create a Cognito User Pool Amazon Cognito User Pools lets you add user sign-up and sign-in capabilities to your web and mobile apps quickly and easily. In this step, we'll create a Cognito user pool for our Wild Rydes app. Use the AWS console to create an Amazon Cognito User Pool requiring e-mail verification. The console's region will default to the last region you were using previously. Change this to the same region where you launched your Cloud9 environment previously. Open the Amazon Cognito console. Choose Manage User Pools . Choose Create a User Pool in the top right of the console. Provide a name for your user pool such as WildRydes . Choose Step through settings to configure our user pool options. Leave Username selected, but additionally select Also allow sign in with verified email address and Also allow sign in with verified phone number . Add a custom attribute for genre that is mutable. This attribute is to give the Unicorn an idea of the riders favorite music genre User Pool Attributes Cognito User Pools have a standard set of attributes available for all users in the pool. These are implemented following the OpenID Connect specification . You can also optionally create up to 25 custom attributes to match any unique claims requirements you may have for your applications. Choose Next step . Policies : Leave password policies and user sign up settings set to default settings and choose Next step . MFA and verifications : Leave the default settings for MFA and email verification and choose Next step . MFA configurations are outside the scope of this workshop Message customizations :Leave the default for message and SES defaults and choose Next step . Tags : Skip adding any tags and click Next step . Devices : Choose No to not remember your user's devices then click Next step . In the next screen, click the Add an app client link . Input wildrydes-web-app as the app client name. Uncheck Generate client secret . Client secrets are used for server-side applications authentication and are not needed for JavaScript applications. They are also are not compatible with the Amplify JS SDK since it's a client library. Choose Create app client and click Next step . Triggers : Leave all Lambda trigger settings set to none and choose Next step . Lambda Triggers These trigger settings allow you to extend the out-of-the-box sign-up and sign-in flows with your own custom logic. You can add authentication challenges, migrate users, and customize verification messages. Review summary of all provided settings for accuracy then choose Create pool . Back in the AWS Cognito console, copy your new User Pool Id into the scratchpad. Choose App clients heading under General settings within the Cognito navigation panel. Copy the App client ID over to your scratchpad. You will be using both of these values later on. Create a Cognito Identity Pool Cognito Identity Pools are used to provide AWS credentials via IAM roles to end-user applications. Since we'll be integrating our Cognito deployment and users with other AWS services, we'll go ahead and create this identity pool now. You will need to create a Cognito Identity Pool linked to the Cognito User Pool and app client ID you just created. Your application will not require un-authenticated users to access any AWS resources, so you do not need to enable access to unauthenticated identities. In the Cognito console, choose Federated Identities in the header bar (top left) to switch to the console for Cognito Federated Identities. Choose Create new Identity pool . Input wildrydes_identity_pool as the Identity pool name. Expand Authentication providers . Within the Cognito tab, input the User Pool ID and App client Id you copied previously to the scratchpad tab. Choose Create Pool . Choose Allow to allow Cognito Identity Pools to setup IAM roles for your application's users. Permissions and settings of these roles can be customized later. Copy/paste the Identity Pool ID , highlighted in red within the code sample in the Get AWS Credentials section, into your Cloud9 scatchpad editor tab. Do not copy the quotation marks, but include the region code and \":\" character. Your scratchpad should now have values for the following Cognito resources: Integrate your application with Amazon Cognito Now that you've created and configured your Cognito User Pool and Identity Pool, you need to configure your application to integrate to Amazon Cognito so it can store user profiles and enable sign-up and sign-in. You will import the AWS Amplify JavaScript library into the project then add sign-up and sign-in utility classes to integrate with our existing UI and front-end components. You'll need to complete the implementation of the onSubmitForm and onSubmitVerification methods within the /website/src/auth/signIn.js file, as well as the methods of the same name within the /website/src/auth/signUp.js file. Finally, you'll need to complete the implementation of a method to check whether the user is authenticated within the /website/src/index.js page. Before using any AWS Amplify modules, we first need to configure Amplify to use our newly created Cognito resources by updating /website/src/amplify-config.js . Open this file in your Cloud9 IDE editor. Copy the following parameter values from your previous scratchpad into the config value parameter placeholders: identityPoolId region userPoolId userPoolWebClientId (App Client ID) Be sure to fill in the '' blanks with your config values. You do not need to modify the example values shown in the comments as they are just for reference and not leveraged by your application. Save your changes to the Amplify config file so your new settings take effect. Any unsaved changes to a file are indicated by a dot icon in the tab of the editor so if you see a gray dot next to the file name, you may have forgotten to save. Next, edit the website/src/index.js file to add the following lines to the top of the file (but below all the other imports) to configure Amplify then save your changes: import Amplify from aws-amplify ; import awsConfig from ./amplify-config ; Amplify . configure ( awsConfig ); After making this changes, your imports should be in the following order: Save your changes to the website/src/index.js file. Next, we need to ensure our application evaluates the user's authenticated state. In the same /website/src/index.js file, find and replace the isAuthenticated method with the code below to use our Amplify library's built-in user session to check this status. const isAuthenticated = () = Amplify . Auth . user !== null ; Save your changes to the /website/src/index.js file. Now that we've imported Amplify and configured the Amplify library, we need to update our application's code to sign-up users using Amplify and Cognito User Pools by finding and replacing the following methods within the /website/src/auth/SignUp.js file with the following code. Only replace the following two methods. The rest of the SignUp.js file should not be modified The onSubmitForm method handles the event when the registration form is submitted. This calls the Auth.signUp method from the AWS Amplify library which registers the user with your Cognito User Pool. The onSubmitVerification method handles the event when the verification code entry form is submitted after the initial registration request. This calls the Auth.confirmSignUp method from the AWS Amplify library which confirms the user registration within your Cognito User Pool. async onSubmitForm ( e ) { e . preventDefault (); try { const params = { username : this . state . email . replace ( /[@.]/g , | ), password : this . state . password , attributes : { email : this . state . email , phone_number : this . state . phone , custom:genre : this . state . genre }, validationData : [] }; const data = await Auth . signUp ( params ); console . log ( data ); this . setState ({ stage : 1 }); } catch ( err ) { if ( err === No userPool ) { // User pool not defined in Amplify config file console . error ( User Pool not defined ); alert ( User Pool not defined. Amplify config must be updated with user pool config ); } else if ( err . message === User already exists ) { // Setting state to allow user to proceed to enter verification code this . setState ({ stage : 1 }); } else { if ( err . message . indexOf ( phone number format ) = 0 ) { err . message = Invalid phone number format. Must include country code. Example: +14252345678 } alert ( err . message ); console . error ( Exception from Auth.signUp: , err ); this . setState ({ stage : 0 , email : , password : , confirm : }); } } } async onSubmitVerification ( e ) { e . preventDefault (); try { const data = await Auth . confirmSignUp ( this . state . email . replace ( /[@.]/g , | ), this . state . code ); console . log ( data ); // Go to the sign in page this . props . history . replace ( /signin ); } catch ( err ) { alert ( err . message ); console . error ( Exception from Auth.confirmSignUp: , err ); } } Save your changes to the /website/src/auth/SignUp.js file. You additionally need to integrate the sign-in capability to use AWS Amplify and Cognito by finding and replacing the following methods within the /website/src/auth/SignIn.js file with the code below. You only need to the following two methods. The rest of the SignIn.js file should not be modified. The onSubmitForm method initiates the signin request with your Cognito User Pool by invoking the Auth.signIn method from AWS Amplify then sets the local state appropriately to indicate the user has signed in successfully. The onSubmitVerification method is used to submit a verification code whenever multi-factor authentication is required to authenticate. For this workshop, this method will not be invoked since you did not require multi-factor authentication earlier when configuring your Cognito User Pool. async onSubmitForm ( e ) { e . preventDefault (); try { const userObject = await Auth . signIn ( this . state . email . replace ( /[@.]/g , | ), this . state . password ); console . log ( userObject , userObject ); if ( userObject . challengeName ) { // Auth challenges are pending prior to token issuance this . setState ({ userObject , stage : 1 }); } else { // No remaining auth challenges need to be satisfied const session = await Auth . currentSession (); // console.log( Cognito User Access Token: , session.getAccessToken().getJwtToken()); console . log ( Cognito User Identity Token: , session . getIdToken (). getJwtToken ()); // console.log( Cognito User Refresh Token , session.getRefreshToken().getToken()); this . setState ({ stage : 0 , email : , password : , code : }); this . props . history . replace ( /app ); } } catch ( err ) { alert ( err . message ); console . error ( Auth.signIn(): , err ); } } async onSubmitVerification ( e ) { e . preventDefault (); try { const data = await Auth . confirmSignIn ( this . state . userObject , this . state . code ); console . log ( Cognito User Data: , data ); const session = await Auth . currentSession (); // console.log( Cognito User Access Token: , session.getAccessToken().getJwtToken()); console . log ( Cognito User Identity Token: , session . getIdToken (). getJwtToken ()); // console.log( Cognito User Refresh Token , session.getRefreshToken().getToken()); this . setState ({ stage : 0 , email : , password : , code : }); this . props . history . replace ( /app ); } catch ( err ) { alert ( err . message ); console . error ( Auth.confirmSignIn(): , err ); } } Save your changes to the /website/src/auth/SignIn.js file. Validate sign-up and sign-in Now that you have integrated our Amplify code into our application, you need to test the site to see that authentication is working end-to-end. Return to your browser tab where you started your Wild Rydes application earlier after popping out from the Cloud9 IDE once in preview mode. This page automatically refreshes after you save any code changes so should now reflect all of your changes and be ready for testing. Click on the Apply link in the menu at the top right (or visit the /register path) of your Cloud9's website to go to the registration page. Input the following: e-mail address (needs to be a valid email address since you'll need to verify your account), phone number with +country_code first preceeding the number (use a sample email address such as +1234567890 ) favorite genre (e.g. jazz , blues , classical , etc.) password twice (Your password must include 8 characters, including uppercase and lowercase characters, and at least 1 number and 1 special character.) Choose Let's Ryde to submit registration. On the verify e-mail screen, enter the one-time code sent to your e-mail address provided then choose Verify . Be sure to check your spam folder for the e-mail with your verification code if you do not see it in your inbox. Assuming no errors were encountered, you will be redirected to the Sign-in screen. Now, re-enter the same e-mail address and password you chose at registration. If the page then loads a map, sign-in was successful and you have successfully integrated Cognito for app authentication. Scroll down beyond the map to copy your user's identity token and decode it by pasting it into the 'encoded' input box at JWT.io . You will see all of your user's attributes are encoded within the token, along with other standard attributes such as the time the token was issued, the time the token expires, the user's unique ID, and more. End of Module 1 Once you have finished setting up the user authentication please wait for the instructions from the presenter to move on to the next module (unless you're running this on your own). If you've finished Module 1 early and would like to further customize the user sign up experience, feel free to run through the next section below. Your current configuration supports a fairly generic user sign-up and sign-in flow. If you have unique requirments for customized flows, you can leverage the built Lambda triggers. These will trigger AWS Lambda functions during user pool operation such as user sign-up, confirmation, and sign-in. You add authentication challenges, migrate users, and customize verification messages. Optional: Pre sign-up validation Use the Lambda triggers to validate the email domain of the user to ensure it's a user from an approved domain prior to allowing them to sign-up. Open the AWS Lambda console. Choose the serverless-idm-wksp-pre-sign-up function. The function was automatically created as part of the environment configuration CloudFormation template but is missing the application code. Copy and paste the code below and save your function: from __future__ import print_function def lambda_handler ( event , context ): # Log event print ( event ) # Set the user pool confirmation flags (you can user these to automatically confirm and a user and associated attributes) event [ response ][ autoConfirmUser ] = False event [ response ][ autoVerifyEmail ] = False event [ response ][ autoVerifyPhone ] = False # Set whitelisted domains domains = [ example.com ] # Split the email address so we can compare domains address = event [ request ][ userAttributes ][ email ] . split ( @ ) # Validate the user is from a whitelisted domain if address [ 1 ] in domains : print ( Pre Sign Up validation succeeded for %s % event [ userName ]) else : print ( Pre Sign Up validation failed for %s % event [ userName ]) raise Exception ( Cannot sign up for the application with that email address. ) # Return to Amazon Cognito return event Be sure to replace the example.com domain with one of your choosing. Now that your Lambda function is configured, you can configure the trigger within your Cognito User Pool. Open the Amazon Cognito console. Choose the WildRydes User Pool. Click Triggers on the left navigation. Under Pre sign-up choose serverless-idm-wksp-pre-sign-up and click Save Changes . Now test out your pre validation logic by deleting the existing user in your User Pool (or create a new user) and ensure the function is triggering and properly validating the email address. Feel free to play around with the logic to test out different validation scenarios. Optional: Customize welcome message Now leverage the Custom Message trigger to customize the welcome message. Open the AWS Lambda console. Choose the serverless-idm-wksp-custom-message function. The function was automatically created as part of the environment configuration CloudFormation template but is missing the application code. Copy and paste the code below and save your function: from __future__ import print_function def lambda_handler ( event , context ): # Log event print ( event ) # This example uses a custom attribute custom:domain if event [ triggerSource ] == CustomMessage_SignUp : event [ response ][ smsMessage ] = Bienvenido al servicio WildRydes. Su c\u00f3digo de confirmaci\u00f3n es %s % event [ request ][ codeParameter ] event [ response ][ emailSubject ] = Bienvenido a WildRydes! event [ response ][ emailMessage ] = Bienvenido al servicio WildRydes. Su c\u00f3digo de confirmaci\u00f3n es %s % event [ request ][ codeParameter ] # Return to Amazon Cognito return event Take note of the event TriggerSource. When else will this Lambda function get triggered? Now that your Lambda function is configured, you can configure the trigger within your Cognito User Pool. In the AWS Management Console choose Services then select Cognito . Choose the WildRydes User Pool. Click Triggers on the left navigation. Under Custom Message choose serverless-idm-wksp-custom-message and click Save Changes . Now follow the same steps as you previously did to test that the trigger is working as intended. Expect a small delay for the confirmation email.","title":"Module 1: Signup and authentication"},{"location":"01-user-auth/#module-1-user-signup-and-authentication","text":"Time : 45 minutes In this module, you will create an Amazon Cognito User Pool and Identity Pool for the Wild Rydes application. The Cognito User Pool will store user profile information and provide sign-up and sign-in capabilities, with the Cognito Identity Pool providing the ability to assume an Identity and Access Management (IAM) role from within the application. Since Wild Rydes is a ride sharing application, a key requirement is that all users must sign-up and sign-in before they're allowed to request a ride. You will configure the application to integrate with Amazon Cognito for these purposes via the AWS Amplify JavaScript library.","title":"Module 1 User signup and authentication"},{"location":"01-user-auth/#architecture","text":"The architecture for this module is very straightforward. All of your static web content including HTML, CSS JavaScript, images and other files will be served locally from your Cloud9 workspace. As you make changes to the website application code, all changes will be automatically updated and shown in your browser via live reload capabilities. For this module, we will be creating a Cognito User Pool as our secure user directory then configuring our application to use the AWS Amplify library to easily integrate Amazon Cognito into our application.","title":"Architecture"},{"location":"01-user-auth/#create-a-cognito-user-pool","text":"Amazon Cognito User Pools lets you add user sign-up and sign-in capabilities to your web and mobile apps quickly and easily. In this step, we'll create a Cognito user pool for our Wild Rydes app. Use the AWS console to create an Amazon Cognito User Pool requiring e-mail verification. The console's region will default to the last region you were using previously. Change this to the same region where you launched your Cloud9 environment previously. Open the Amazon Cognito console. Choose Manage User Pools . Choose Create a User Pool in the top right of the console. Provide a name for your user pool such as WildRydes . Choose Step through settings to configure our user pool options. Leave Username selected, but additionally select Also allow sign in with verified email address and Also allow sign in with verified phone number . Add a custom attribute for genre that is mutable. This attribute is to give the Unicorn an idea of the riders favorite music genre User Pool Attributes Cognito User Pools have a standard set of attributes available for all users in the pool. These are implemented following the OpenID Connect specification . You can also optionally create up to 25 custom attributes to match any unique claims requirements you may have for your applications. Choose Next step . Policies : Leave password policies and user sign up settings set to default settings and choose Next step . MFA and verifications : Leave the default settings for MFA and email verification and choose Next step . MFA configurations are outside the scope of this workshop Message customizations :Leave the default for message and SES defaults and choose Next step . Tags : Skip adding any tags and click Next step . Devices : Choose No to not remember your user's devices then click Next step . In the next screen, click the Add an app client link . Input wildrydes-web-app as the app client name. Uncheck Generate client secret . Client secrets are used for server-side applications authentication and are not needed for JavaScript applications. They are also are not compatible with the Amplify JS SDK since it's a client library. Choose Create app client and click Next step . Triggers : Leave all Lambda trigger settings set to none and choose Next step . Lambda Triggers These trigger settings allow you to extend the out-of-the-box sign-up and sign-in flows with your own custom logic. You can add authentication challenges, migrate users, and customize verification messages. Review summary of all provided settings for accuracy then choose Create pool . Back in the AWS Cognito console, copy your new User Pool Id into the scratchpad. Choose App clients heading under General settings within the Cognito navigation panel. Copy the App client ID over to your scratchpad. You will be using both of these values later on.","title":"Create a Cognito User Pool"},{"location":"01-user-auth/#create-a-cognito-identity-pool","text":"Cognito Identity Pools are used to provide AWS credentials via IAM roles to end-user applications. Since we'll be integrating our Cognito deployment and users with other AWS services, we'll go ahead and create this identity pool now. You will need to create a Cognito Identity Pool linked to the Cognito User Pool and app client ID you just created. Your application will not require un-authenticated users to access any AWS resources, so you do not need to enable access to unauthenticated identities. In the Cognito console, choose Federated Identities in the header bar (top left) to switch to the console for Cognito Federated Identities. Choose Create new Identity pool . Input wildrydes_identity_pool as the Identity pool name. Expand Authentication providers . Within the Cognito tab, input the User Pool ID and App client Id you copied previously to the scratchpad tab. Choose Create Pool . Choose Allow to allow Cognito Identity Pools to setup IAM roles for your application's users. Permissions and settings of these roles can be customized later. Copy/paste the Identity Pool ID , highlighted in red within the code sample in the Get AWS Credentials section, into your Cloud9 scatchpad editor tab. Do not copy the quotation marks, but include the region code and \":\" character. Your scratchpad should now have values for the following Cognito resources:","title":"Create a Cognito Identity Pool"},{"location":"01-user-auth/#integrate-your-application-with-amazon-cognito","text":"Now that you've created and configured your Cognito User Pool and Identity Pool, you need to configure your application to integrate to Amazon Cognito so it can store user profiles and enable sign-up and sign-in. You will import the AWS Amplify JavaScript library into the project then add sign-up and sign-in utility classes to integrate with our existing UI and front-end components. You'll need to complete the implementation of the onSubmitForm and onSubmitVerification methods within the /website/src/auth/signIn.js file, as well as the methods of the same name within the /website/src/auth/signUp.js file. Finally, you'll need to complete the implementation of a method to check whether the user is authenticated within the /website/src/index.js page. Before using any AWS Amplify modules, we first need to configure Amplify to use our newly created Cognito resources by updating /website/src/amplify-config.js . Open this file in your Cloud9 IDE editor. Copy the following parameter values from your previous scratchpad into the config value parameter placeholders: identityPoolId region userPoolId userPoolWebClientId (App Client ID) Be sure to fill in the '' blanks with your config values. You do not need to modify the example values shown in the comments as they are just for reference and not leveraged by your application. Save your changes to the Amplify config file so your new settings take effect. Any unsaved changes to a file are indicated by a dot icon in the tab of the editor so if you see a gray dot next to the file name, you may have forgotten to save. Next, edit the website/src/index.js file to add the following lines to the top of the file (but below all the other imports) to configure Amplify then save your changes: import Amplify from aws-amplify ; import awsConfig from ./amplify-config ; Amplify . configure ( awsConfig ); After making this changes, your imports should be in the following order: Save your changes to the website/src/index.js file. Next, we need to ensure our application evaluates the user's authenticated state. In the same /website/src/index.js file, find and replace the isAuthenticated method with the code below to use our Amplify library's built-in user session to check this status. const isAuthenticated = () = Amplify . Auth . user !== null ; Save your changes to the /website/src/index.js file. Now that we've imported Amplify and configured the Amplify library, we need to update our application's code to sign-up users using Amplify and Cognito User Pools by finding and replacing the following methods within the /website/src/auth/SignUp.js file with the following code. Only replace the following two methods. The rest of the SignUp.js file should not be modified The onSubmitForm method handles the event when the registration form is submitted. This calls the Auth.signUp method from the AWS Amplify library which registers the user with your Cognito User Pool. The onSubmitVerification method handles the event when the verification code entry form is submitted after the initial registration request. This calls the Auth.confirmSignUp method from the AWS Amplify library which confirms the user registration within your Cognito User Pool. async onSubmitForm ( e ) { e . preventDefault (); try { const params = { username : this . state . email . replace ( /[@.]/g , | ), password : this . state . password , attributes : { email : this . state . email , phone_number : this . state . phone , custom:genre : this . state . genre }, validationData : [] }; const data = await Auth . signUp ( params ); console . log ( data ); this . setState ({ stage : 1 }); } catch ( err ) { if ( err === No userPool ) { // User pool not defined in Amplify config file console . error ( User Pool not defined ); alert ( User Pool not defined. Amplify config must be updated with user pool config ); } else if ( err . message === User already exists ) { // Setting state to allow user to proceed to enter verification code this . setState ({ stage : 1 }); } else { if ( err . message . indexOf ( phone number format ) = 0 ) { err . message = Invalid phone number format. Must include country code. Example: +14252345678 } alert ( err . message ); console . error ( Exception from Auth.signUp: , err ); this . setState ({ stage : 0 , email : , password : , confirm : }); } } } async onSubmitVerification ( e ) { e . preventDefault (); try { const data = await Auth . confirmSignUp ( this . state . email . replace ( /[@.]/g , | ), this . state . code ); console . log ( data ); // Go to the sign in page this . props . history . replace ( /signin ); } catch ( err ) { alert ( err . message ); console . error ( Exception from Auth.confirmSignUp: , err ); } } Save your changes to the /website/src/auth/SignUp.js file. You additionally need to integrate the sign-in capability to use AWS Amplify and Cognito by finding and replacing the following methods within the /website/src/auth/SignIn.js file with the code below. You only need to the following two methods. The rest of the SignIn.js file should not be modified. The onSubmitForm method initiates the signin request with your Cognito User Pool by invoking the Auth.signIn method from AWS Amplify then sets the local state appropriately to indicate the user has signed in successfully. The onSubmitVerification method is used to submit a verification code whenever multi-factor authentication is required to authenticate. For this workshop, this method will not be invoked since you did not require multi-factor authentication earlier when configuring your Cognito User Pool. async onSubmitForm ( e ) { e . preventDefault (); try { const userObject = await Auth . signIn ( this . state . email . replace ( /[@.]/g , | ), this . state . password ); console . log ( userObject , userObject ); if ( userObject . challengeName ) { // Auth challenges are pending prior to token issuance this . setState ({ userObject , stage : 1 }); } else { // No remaining auth challenges need to be satisfied const session = await Auth . currentSession (); // console.log( Cognito User Access Token: , session.getAccessToken().getJwtToken()); console . log ( Cognito User Identity Token: , session . getIdToken (). getJwtToken ()); // console.log( Cognito User Refresh Token , session.getRefreshToken().getToken()); this . setState ({ stage : 0 , email : , password : , code : }); this . props . history . replace ( /app ); } } catch ( err ) { alert ( err . message ); console . error ( Auth.signIn(): , err ); } } async onSubmitVerification ( e ) { e . preventDefault (); try { const data = await Auth . confirmSignIn ( this . state . userObject , this . state . code ); console . log ( Cognito User Data: , data ); const session = await Auth . currentSession (); // console.log( Cognito User Access Token: , session.getAccessToken().getJwtToken()); console . log ( Cognito User Identity Token: , session . getIdToken (). getJwtToken ()); // console.log( Cognito User Refresh Token , session.getRefreshToken().getToken()); this . setState ({ stage : 0 , email : , password : , code : }); this . props . history . replace ( /app ); } catch ( err ) { alert ( err . message ); console . error ( Auth.confirmSignIn(): , err ); } } Save your changes to the /website/src/auth/SignIn.js file.","title":"Integrate your application with Amazon Cognito"},{"location":"01-user-auth/#validate-sign-up-and-sign-in","text":"Now that you have integrated our Amplify code into our application, you need to test the site to see that authentication is working end-to-end. Return to your browser tab where you started your Wild Rydes application earlier after popping out from the Cloud9 IDE once in preview mode. This page automatically refreshes after you save any code changes so should now reflect all of your changes and be ready for testing. Click on the Apply link in the menu at the top right (or visit the /register path) of your Cloud9's website to go to the registration page. Input the following: e-mail address (needs to be a valid email address since you'll need to verify your account), phone number with +country_code first preceeding the number (use a sample email address such as +1234567890 ) favorite genre (e.g. jazz , blues , classical , etc.) password twice (Your password must include 8 characters, including uppercase and lowercase characters, and at least 1 number and 1 special character.) Choose Let's Ryde to submit registration. On the verify e-mail screen, enter the one-time code sent to your e-mail address provided then choose Verify . Be sure to check your spam folder for the e-mail with your verification code if you do not see it in your inbox. Assuming no errors were encountered, you will be redirected to the Sign-in screen. Now, re-enter the same e-mail address and password you chose at registration. If the page then loads a map, sign-in was successful and you have successfully integrated Cognito for app authentication. Scroll down beyond the map to copy your user's identity token and decode it by pasting it into the 'encoded' input box at JWT.io . You will see all of your user's attributes are encoded within the token, along with other standard attributes such as the time the token was issued, the time the token expires, the user's unique ID, and more.","title":"Validate sign-up and sign-in"},{"location":"01-user-auth/#end-of-module-1","text":"Once you have finished setting up the user authentication please wait for the instructions from the presenter to move on to the next module (unless you're running this on your own). If you've finished Module 1 early and would like to further customize the user sign up experience, feel free to run through the next section below. Your current configuration supports a fairly generic user sign-up and sign-in flow. If you have unique requirments for customized flows, you can leverage the built Lambda triggers. These will trigger AWS Lambda functions during user pool operation such as user sign-up, confirmation, and sign-in. You add authentication challenges, migrate users, and customize verification messages.","title":"End of Module 1"},{"location":"01-user-auth/#optional-pre-sign-up-validation","text":"Use the Lambda triggers to validate the email domain of the user to ensure it's a user from an approved domain prior to allowing them to sign-up. Open the AWS Lambda console. Choose the serverless-idm-wksp-pre-sign-up function. The function was automatically created as part of the environment configuration CloudFormation template but is missing the application code. Copy and paste the code below and save your function: from __future__ import print_function def lambda_handler ( event , context ): # Log event print ( event ) # Set the user pool confirmation flags (you can user these to automatically confirm and a user and associated attributes) event [ response ][ autoConfirmUser ] = False event [ response ][ autoVerifyEmail ] = False event [ response ][ autoVerifyPhone ] = False # Set whitelisted domains domains = [ example.com ] # Split the email address so we can compare domains address = event [ request ][ userAttributes ][ email ] . split ( @ ) # Validate the user is from a whitelisted domain if address [ 1 ] in domains : print ( Pre Sign Up validation succeeded for %s % event [ userName ]) else : print ( Pre Sign Up validation failed for %s % event [ userName ]) raise Exception ( Cannot sign up for the application with that email address. ) # Return to Amazon Cognito return event Be sure to replace the example.com domain with one of your choosing. Now that your Lambda function is configured, you can configure the trigger within your Cognito User Pool. Open the Amazon Cognito console. Choose the WildRydes User Pool. Click Triggers on the left navigation. Under Pre sign-up choose serverless-idm-wksp-pre-sign-up and click Save Changes . Now test out your pre validation logic by deleting the existing user in your User Pool (or create a new user) and ensure the function is triggering and properly validating the email address. Feel free to play around with the logic to test out different validation scenarios.","title":"Optional: Pre sign-up validation"},{"location":"01-user-auth/#optional-customize-welcome-message","text":"Now leverage the Custom Message trigger to customize the welcome message. Open the AWS Lambda console. Choose the serverless-idm-wksp-custom-message function. The function was automatically created as part of the environment configuration CloudFormation template but is missing the application code. Copy and paste the code below and save your function: from __future__ import print_function def lambda_handler ( event , context ): # Log event print ( event ) # This example uses a custom attribute custom:domain if event [ triggerSource ] == CustomMessage_SignUp : event [ response ][ smsMessage ] = Bienvenido al servicio WildRydes. Su c\u00f3digo de confirmaci\u00f3n es %s % event [ request ][ codeParameter ] event [ response ][ emailSubject ] = Bienvenido a WildRydes! event [ response ][ emailMessage ] = Bienvenido al servicio WildRydes. Su c\u00f3digo de confirmaci\u00f3n es %s % event [ request ][ codeParameter ] # Return to Amazon Cognito return event Take note of the event TriggerSource. When else will this Lambda function get triggered? Now that your Lambda function is configured, you can configure the trigger within your Cognito User Pool. In the AWS Management Console choose Services then select Cognito . Choose the WildRydes User Pool. Click Triggers on the left navigation. Under Custom Message choose serverless-idm-wksp-custom-message and click Save Changes . Now follow the same steps as you previously did to test that the trigger is working as intended. Expect a small delay for the confirmation email.","title":"Optional: Customize welcome message"},{"location":"02-backend-auth/","text":"Module 2 Backend authorization with Amazon API Gateway Time : 30 minutes In this module, you will add a serverless backend to your Wild Rydes application leveraging Amazon API Gateway and AWS Lambda . You will then enable authentication and authorization on your API to secure the backend to only accept valid, authorized requests. Architecture Building on Module 1, this module will add a Serverless backend built using Amazon API Gateway and AWS Lambda. For persistence, you will use Amazon DynamoDB as a NoSQL data store. All of the above services are serverless so you can seamlessly scale your application as your demands grow. After creating the API, we will integrate our client application to call it via the AWS Amplify library. Launch the Serverless API backend You will be creating your Serverless API built with Amazon API Gateway, AWS Lambda, and Amazon DynamoDB via a CloudFormation template. Since this workshop is focused on authentication and authorization, this template will create the backend infrastructure, but not enable any security settings and the rest of the module will enable and configure such settings. Create a new WildRydes Serverless Backend stack by launching a CloudFormation stack based on the serverless-backend.yaml file in the templates folder. This WildRydes backend CloudFormation template will provision your API Gateway deployment with Lambda functions for compute, a DynamoDB database for persistence, and an S3 bucket for photo uploads which will be used in module 3. Additionally, the necessary function invocation permissions and execution role for the Lambda function will also be provisioned. Region Deploy us-east-1 (N. Virginia) us-east-2 (Ohio) us-west-2 (Oregon) Click the Deploy to AWS button above. This will automatically take you to the console to run the template. The Specify an Amazon S3 template URL is already selected and the template URL is automatically added. Click Next . On the Specify Details click Next . On the Options click Next (leave everything on this page as the default). On the Review page, choose to Acknowledge that the CloudFormation template may create IAM resources with custom names , review the summary details, and then click Create stack . It will take a few minutes for the Stack to create. Choose the Stack Info tab to go to the overall stack status page and wait until the stack is fully launched and shows a status of CREATE_COMPLETE . Click the refresh icon periodically to see progress update. With the serverless-idm-backend stack selected, click on the Outputs tab and copy the value shown for the WildRydesApiInvokeUrl to your Cloud9 scratchpad editor tab. Integrate your API Now that you have created our Serverless API, you need to update your Wild Rydes web application to integrate with it. You will leverage the AWS Amplify client library to make API calls and inject security seamlessly to support your authentication and authorization scenarios. First, you need to update the /website/src/amplify-config.js file to include your new API Gateway endpoint. Store the endpoint including the /prod at the end in the endpoint property under the WildRydesAPI section. Do not change the name WildRydesAPI in this configuration file. API: { endpoints: [ { name: WildRydesAPI , endpoint: https://1ngrgqjt6c.execute-api.us-east-1.amazonaws.com/prod , region: us-east-1 } ] }, Next, you need to enable the hasAPI method by uncommenting its code within /website/src/pages/MainApp.js . hasApi () { const api = awsConfig . API . endpoints . filter ( v = v . endpoint !== ); return ( typeof api !== undefined ); } Finally, within the same file, we will implement the API request for a ride as a POST request to our API which sends a body containing the requested latitude and longitude as the pickup location. Update the getData() method to be as follows: async getData ( pin ) { const apiRequest = { body : { PickupLocation : { Longitude : pin . longitude , Latitude : pin . latitude } }, headers : { Authorization : , // To be updated Content-Type : application/json } }; console . log ( API Request: , apiRequest ); return await API . post ( apiName , apiPath , apiRequest ); } Validate API functionality and integration Now that you've integrated code changes to call your new Serverless API, you should test the end-to-end user experience to ensure the application is working correctly. The API currently requires no authentication so any request will currently be accepted until we enable required authentication. Go back to your browser tab with Wild Rydes running and sign-in again at /signin . Once signed in, click anywhere on the map to indicate a pickup location, then select the Request button to call your ride. You should be informed of your unicorn's arrival momentarily. Enable API Gateway authorization with Cognito Amazon API Gateway can use the JSON Web tokens (JWT) returned by Cognito User Pools to authenticate API calls. In this step, you'll configure an authorizer for your API to use the user pool you created in module 1. Since Cognito User Pools implements OpenID Connect JSON web tokens, API Gateway is able to compare the signature of an access or identity token against the known public keys of the Cognito User Pool which allows verification and authentication to happen without having to write additional code in your application. In the Amazon API Gateway console, create a new Cognito user pool authorizer for your API. Configure it to use the user pool that you created in the previous module. You can test the configuration in the console by copying and pasting the identity token printed to the console after you log in via the /signin path of your current website. Once setup, you will change your application's code to send the proper JSON web token with its API requests to authenticate. In the AWS Management Console choose Services then select API Gateway under Networking and Content Delivery. Choose the API named WildRydes . Under your newly created API, choose Authorizers . Chose Create New Authorizer . Enter WildRydes for the Authorizer name. Select Cognito for the type. In the Region drop-down under Cognito User Pool , select the Region where you created your Cognito user pool in the last module (by default the current region should be selected). Enter WildRydes (or the name you gave your user pool) in the Cognito User Pool input. Enter Authorization for the Token Source . Leave Token Validation blank without editing. Choose Create . Verify your authorizer configuration In a different browser tab, return to your Wild Rydes application and sign-in if you're not already signed in. After signing in, you should be redirected to /app . Open your browser's developer console and browse to the console log output section. Look for the console log to say Cognito User Identity Token: and a long string beneath the message. Copy the long string to your clipboard without the intro message. You will need to copy across multiple lines to fully copy the token in its entirety. Go back to previous tab where you have just finished creating the Authorizer. Click Test at the bottom of the card for the authorizer. Paste the auth token into the Authorization Token field in the popup dialog. Click Test button and verify that the response code is 200 and that you see the claims for your user displayed. Since this is the identity token, the user's attributes are encoded within the JWT as claims which can be read parsed programatically. If you do not receive successful test results as shown below, do not proceed until you're able to validate the authorizer is configured properly and passes this test. Require Cognito authentication for API Gateway Browse to Resources while within your Wild Rydes API in the API Gateway console. Select the POST method under the /ride resource path. Choose Method Request Choose the pencil icon next to Authorization to edit the setting. Select your new Cognito Authorizer from the list of options presented. If you don't see this option listed, Reload the browser page then this authorizer option should appear in the drop-down list. Save your selection by clicking the checkmark icon next to the drop down. Next, choose the Actions button at the top of the resources list. Choose Deploy API from the list of options presented. For deployment stage, select prod then click Deploy . You've now successfully deployed your new authentication integration to your API's production environment. Configure your Wild Rydes web app to authenticate API requests Now that you've deployed the new authorizer configuration to production, all API requests must be authenticated to be processed. Return to your Wild Rydes app, sign in at /signin if necessary, and attempt to request a ride. You should receive an Error finding unicorn . If you open the developer console, you will see that we received a HTTP 401 error, which means it was an unauthorized request. To authenticate our requests properly, we need to send an Authorization header. If you at first still that you requests go through without any errors, try requesting a ride again in 30-60 seconds to allow the API Gateway changes to fully propagate. Go back to Cloud9 and open the /website/src/pages/MainApp.js files. Browse down to the getData method you previously updated. You will notice that the headers for the request currently include a blank Authorization header. Replace your current getData method with the following code which sends your user's Cognito identity token, encoded as a JSON web token, in the Authorization header with every request. async getData ( pin ) { const apiRequest = { body : { PickupLocation : { Longitude : pin . longitude , Latitude : pin . latitude } }, headers : { Authorization : this . state . idToken , Content-Type : application/json } }; console . log ( API Request: , apiRequest ); return await API . post ( apiName , apiPath , apiRequest ); } Allow the application to refresh, sign-in again, and request a ride. The unicorn ride request should be fulfilled as before now. To see the full request headers which were sent, look at the developer console for an API Request informational message which includes the API Request details once expanded, including the full headers and body of the request. If the API now invokes correctly and application functions as expected summoning unicorns, you may proceed to the next module. End of Module 2 Once you have finished setting up the backend authorization please wait for the instructions from the presenter to move on to the next module (unless you're running this on your own). If you've finished Module 2 early and to try out some alternative authorzation methods, feel free to run through the next few sections. In this optional extension, you will update your serverless backend for your Wild Rydes application leveraging Amazon API Gateway and AWS Lambda to use request signing with IAM-based authorization as a more secure authentication option. Optional: API Gateway Authorization with AWS IAM This section updates your Serverless backend built earlier using Amazon API Gateway and AWS Lambda to use IAM-based authorization. This extends your authorization capability to offer fine-grained access control authorizing differently per API operation and enhancing security via request signing. By enabling IAM-based authorization, you will use the same type of authentication, authorization, and request signing used by all AWS services and SDKs. Request signing is a more secure implementation of API request authentication where each API request made is signed with a signature unique to the request itself. Hence, no static API keys or bearer tokens are directly sent to the backend service and any man-in-the-middle attacks would not be able to use such API keys or bearer tokens to impersonate a valid user with the backend resources. AWS APIs and SDKs use a request signing algorithm named Signature V4 (Sigv4) which is what you will enable your API to use in this module. For production APIs, you should use either the token-based authorization OR request signing authorization via IAM demonstrated in this module, but not use both for the same API. Attach an IAM policy to your Cognito authenticated users' role For you to be able to use request signing and IAM-based fine-grained access control, we'll first need to associate an IAM policy that provides permissions to invoke API operations for your API Gateway deployment. For further details, you can review controlling access to an API with IAM permissions documentation. Go the AWS Management Console, click Services then select IAM under Security, Identity, and Compliance. Choose Policies . Search for WildRydes to see the WildRydesAPI-StandardUserPolicy which was created by the Serverless Backed CloudFormation template. Click the WildRydesAPI-StandardUserPolicy policy name. Review the policy which was created by CloudFormation to authorize requests to your API Gateway deployment. This policy allows access to invoke any method on the /ride path for any API stage of your API gateway backend. For more details about authoring IAM policies for API Gateway, visit the controlling access to an API with IAM permissions documentation. Choose Roles . Search for WildRydes to find the two roles which were created by Cognito Identity Pools when you created the Identity Pool in module one. Should you not be able to find the roles here, you can alternatively go to the Cognito Federated Identities console, find the correct identity pool, then click Edit Identity Pool in the top-right corner to see the roles listed. Each identity pool has both an Unauthenticated user role and an Authenticated user role. Select the Auth* role for your authenticated users. If the full name of the role is hidden from view due to column width, you can hover over the partially visible name of the role to see the full name of the role as a tool tip. Choose Attach policies . Search for WildRydes and check the box next to the policy named WildRydesAPI-StandardUserAccess . Choose Attach policy . You should now see the WildRydesAPI-StandardUserAccess policy associated with your Cognito IAM auth role. Enable API Gateway authorization with AWS IAM In addition to using JSON Web Tokens (JWTs) for authentication, API Gateway can leverage AWS request signing and parse the request signature to determine the requesting user. In this step, you'll update your authorization type to IAM for your API which will then use AWS's Identity and Access Management (IAM) capabilities to authorize requests via IAM policies. In the Amazon API Gateway console, update the authorization type to AWS_IAM for the POST method on the /ride resource. Next, re-deploy the API to make your change take effect. In the AWS Management Console choose Services then select API Gateway under Networking and Content Delivery. Choose the API named WildRydes . Browse to Resources while within your Wild Rydes API in the API Gateway console. Select the POST method under the /ride resource path. Choose Method Request Choose the pencil icon next to Authorization to edit the setting. Select AWS_IAM from the list of authorization options presented. Save your selection by clicking the checkmark icon next to the drop down. Next, choose the Actions button at the top of the resources list. Choose Deploy API from the list of options presented. For deployment stage, select prod then click Deploy . You've now successfully deployed your new authentication integration to your API's production environment. Configure your app to authenticate API requests Now that you've deployed the new authorizer configuration to production, all API requests must be authenticated to be processed. Return to your Wild Rydes app, sign in at /signin if necessary, and attempt to request a ride. You should receive an Error finding unicorn . If you open the developer console, you will see that we received a HTTP 401 error, which means it was an unauthorized request. If at first your requests go through without any errors, try requesting a ride again in 30-60 seconds to allow time for the API Gateway changes to fully propagate. Go back to Cloud9 and open the /website/src/pages/MainApp.js files. Update your current getData method to the following method, which removes the Authorization header and adds debugging information to show us the request signature as requests are sent. The default behavior of the AWS Amplify library is the sign all requests with SigV4 signing when no authorization header is specified, so this will automatically sign all requests using this algorithm without extra development effort. Save your changes after making this update. async getData ( pin ) { Amplify . Logger . LOG_LEVEL = DEBUG ; const apiRequest = { body : { PickupLocation : { Longitude : pin . longitude , Latitude : pin . latitude } }, headers : { Content-Type : application/json } }; console . log ( API Request: , apiRequest ); return await API . post ( apiName , apiPath , apiRequest ); } Allow the application to refresh, sign-in again, and request a ride. The unicorn ride request should be fulfilled as before now. To see the full request headers which were sent, look at the developer console for an message which includes the API Request details, including the full signature and headers of the request. This message starts with POST /prod/ride then shows the headers of the request made. You may notice that there were both x-amz-date and x-amz-security-token headers sent among other headers. These two headers are part of the overall request signature, along with the Authorization header.","title":"Module 2: Backend authorization"},{"location":"02-backend-auth/#module-2-backend-authorization-with-amazon-api-gateway","text":"Time : 30 minutes In this module, you will add a serverless backend to your Wild Rydes application leveraging Amazon API Gateway and AWS Lambda . You will then enable authentication and authorization on your API to secure the backend to only accept valid, authorized requests.","title":"Module 2 Backend authorization with Amazon API Gateway"},{"location":"02-backend-auth/#architecture","text":"Building on Module 1, this module will add a Serverless backend built using Amazon API Gateway and AWS Lambda. For persistence, you will use Amazon DynamoDB as a NoSQL data store. All of the above services are serverless so you can seamlessly scale your application as your demands grow. After creating the API, we will integrate our client application to call it via the AWS Amplify library.","title":"Architecture"},{"location":"02-backend-auth/#launch-the-serverless-api-backend","text":"You will be creating your Serverless API built with Amazon API Gateway, AWS Lambda, and Amazon DynamoDB via a CloudFormation template. Since this workshop is focused on authentication and authorization, this template will create the backend infrastructure, but not enable any security settings and the rest of the module will enable and configure such settings. Create a new WildRydes Serverless Backend stack by launching a CloudFormation stack based on the serverless-backend.yaml file in the templates folder. This WildRydes backend CloudFormation template will provision your API Gateway deployment with Lambda functions for compute, a DynamoDB database for persistence, and an S3 bucket for photo uploads which will be used in module 3. Additionally, the necessary function invocation permissions and execution role for the Lambda function will also be provisioned. Region Deploy us-east-1 (N. Virginia) us-east-2 (Ohio) us-west-2 (Oregon) Click the Deploy to AWS button above. This will automatically take you to the console to run the template. The Specify an Amazon S3 template URL is already selected and the template URL is automatically added. Click Next . On the Specify Details click Next . On the Options click Next (leave everything on this page as the default). On the Review page, choose to Acknowledge that the CloudFormation template may create IAM resources with custom names , review the summary details, and then click Create stack . It will take a few minutes for the Stack to create. Choose the Stack Info tab to go to the overall stack status page and wait until the stack is fully launched and shows a status of CREATE_COMPLETE . Click the refresh icon periodically to see progress update. With the serverless-idm-backend stack selected, click on the Outputs tab and copy the value shown for the WildRydesApiInvokeUrl to your Cloud9 scratchpad editor tab.","title":"Launch the Serverless API backend"},{"location":"02-backend-auth/#integrate-your-api","text":"Now that you have created our Serverless API, you need to update your Wild Rydes web application to integrate with it. You will leverage the AWS Amplify client library to make API calls and inject security seamlessly to support your authentication and authorization scenarios. First, you need to update the /website/src/amplify-config.js file to include your new API Gateway endpoint. Store the endpoint including the /prod at the end in the endpoint property under the WildRydesAPI section. Do not change the name WildRydesAPI in this configuration file. API: { endpoints: [ { name: WildRydesAPI , endpoint: https://1ngrgqjt6c.execute-api.us-east-1.amazonaws.com/prod , region: us-east-1 } ] }, Next, you need to enable the hasAPI method by uncommenting its code within /website/src/pages/MainApp.js . hasApi () { const api = awsConfig . API . endpoints . filter ( v = v . endpoint !== ); return ( typeof api !== undefined ); } Finally, within the same file, we will implement the API request for a ride as a POST request to our API which sends a body containing the requested latitude and longitude as the pickup location. Update the getData() method to be as follows: async getData ( pin ) { const apiRequest = { body : { PickupLocation : { Longitude : pin . longitude , Latitude : pin . latitude } }, headers : { Authorization : , // To be updated Content-Type : application/json } }; console . log ( API Request: , apiRequest ); return await API . post ( apiName , apiPath , apiRequest ); }","title":"Integrate your API"},{"location":"02-backend-auth/#validate-api-functionality-and-integration","text":"Now that you've integrated code changes to call your new Serverless API, you should test the end-to-end user experience to ensure the application is working correctly. The API currently requires no authentication so any request will currently be accepted until we enable required authentication. Go back to your browser tab with Wild Rydes running and sign-in again at /signin . Once signed in, click anywhere on the map to indicate a pickup location, then select the Request button to call your ride. You should be informed of your unicorn's arrival momentarily.","title":"Validate API functionality and integration"},{"location":"02-backend-auth/#enable-api-gateway-authorization-with-cognito","text":"Amazon API Gateway can use the JSON Web tokens (JWT) returned by Cognito User Pools to authenticate API calls. In this step, you'll configure an authorizer for your API to use the user pool you created in module 1. Since Cognito User Pools implements OpenID Connect JSON web tokens, API Gateway is able to compare the signature of an access or identity token against the known public keys of the Cognito User Pool which allows verification and authentication to happen without having to write additional code in your application. In the Amazon API Gateway console, create a new Cognito user pool authorizer for your API. Configure it to use the user pool that you created in the previous module. You can test the configuration in the console by copying and pasting the identity token printed to the console after you log in via the /signin path of your current website. Once setup, you will change your application's code to send the proper JSON web token with its API requests to authenticate. In the AWS Management Console choose Services then select API Gateway under Networking and Content Delivery. Choose the API named WildRydes . Under your newly created API, choose Authorizers . Chose Create New Authorizer . Enter WildRydes for the Authorizer name. Select Cognito for the type. In the Region drop-down under Cognito User Pool , select the Region where you created your Cognito user pool in the last module (by default the current region should be selected). Enter WildRydes (or the name you gave your user pool) in the Cognito User Pool input. Enter Authorization for the Token Source . Leave Token Validation blank without editing. Choose Create . Verify your authorizer configuration In a different browser tab, return to your Wild Rydes application and sign-in if you're not already signed in. After signing in, you should be redirected to /app . Open your browser's developer console and browse to the console log output section. Look for the console log to say Cognito User Identity Token: and a long string beneath the message. Copy the long string to your clipboard without the intro message. You will need to copy across multiple lines to fully copy the token in its entirety. Go back to previous tab where you have just finished creating the Authorizer. Click Test at the bottom of the card for the authorizer. Paste the auth token into the Authorization Token field in the popup dialog. Click Test button and verify that the response code is 200 and that you see the claims for your user displayed. Since this is the identity token, the user's attributes are encoded within the JWT as claims which can be read parsed programatically. If you do not receive successful test results as shown below, do not proceed until you're able to validate the authorizer is configured properly and passes this test. Require Cognito authentication for API Gateway Browse to Resources while within your Wild Rydes API in the API Gateway console. Select the POST method under the /ride resource path. Choose Method Request Choose the pencil icon next to Authorization to edit the setting. Select your new Cognito Authorizer from the list of options presented. If you don't see this option listed, Reload the browser page then this authorizer option should appear in the drop-down list. Save your selection by clicking the checkmark icon next to the drop down. Next, choose the Actions button at the top of the resources list. Choose Deploy API from the list of options presented. For deployment stage, select prod then click Deploy . You've now successfully deployed your new authentication integration to your API's production environment. Configure your Wild Rydes web app to authenticate API requests Now that you've deployed the new authorizer configuration to production, all API requests must be authenticated to be processed. Return to your Wild Rydes app, sign in at /signin if necessary, and attempt to request a ride. You should receive an Error finding unicorn . If you open the developer console, you will see that we received a HTTP 401 error, which means it was an unauthorized request. To authenticate our requests properly, we need to send an Authorization header. If you at first still that you requests go through without any errors, try requesting a ride again in 30-60 seconds to allow the API Gateway changes to fully propagate. Go back to Cloud9 and open the /website/src/pages/MainApp.js files. Browse down to the getData method you previously updated. You will notice that the headers for the request currently include a blank Authorization header. Replace your current getData method with the following code which sends your user's Cognito identity token, encoded as a JSON web token, in the Authorization header with every request. async getData ( pin ) { const apiRequest = { body : { PickupLocation : { Longitude : pin . longitude , Latitude : pin . latitude } }, headers : { Authorization : this . state . idToken , Content-Type : application/json } }; console . log ( API Request: , apiRequest ); return await API . post ( apiName , apiPath , apiRequest ); } Allow the application to refresh, sign-in again, and request a ride. The unicorn ride request should be fulfilled as before now. To see the full request headers which were sent, look at the developer console for an API Request informational message which includes the API Request details once expanded, including the full headers and body of the request. If the API now invokes correctly and application functions as expected summoning unicorns, you may proceed to the next module.","title":"Enable API Gateway authorization with Cognito"},{"location":"02-backend-auth/#end-of-module-2","text":"Once you have finished setting up the backend authorization please wait for the instructions from the presenter to move on to the next module (unless you're running this on your own). If you've finished Module 2 early and to try out some alternative authorzation methods, feel free to run through the next few sections. In this optional extension, you will update your serverless backend for your Wild Rydes application leveraging Amazon API Gateway and AWS Lambda to use request signing with IAM-based authorization as a more secure authentication option.","title":"End of Module 2"},{"location":"02-backend-auth/#optional-api-gateway-authorization-with-aws-iam","text":"This section updates your Serverless backend built earlier using Amazon API Gateway and AWS Lambda to use IAM-based authorization. This extends your authorization capability to offer fine-grained access control authorizing differently per API operation and enhancing security via request signing. By enabling IAM-based authorization, you will use the same type of authentication, authorization, and request signing used by all AWS services and SDKs. Request signing is a more secure implementation of API request authentication where each API request made is signed with a signature unique to the request itself. Hence, no static API keys or bearer tokens are directly sent to the backend service and any man-in-the-middle attacks would not be able to use such API keys or bearer tokens to impersonate a valid user with the backend resources. AWS APIs and SDKs use a request signing algorithm named Signature V4 (Sigv4) which is what you will enable your API to use in this module. For production APIs, you should use either the token-based authorization OR request signing authorization via IAM demonstrated in this module, but not use both for the same API. Attach an IAM policy to your Cognito authenticated users' role For you to be able to use request signing and IAM-based fine-grained access control, we'll first need to associate an IAM policy that provides permissions to invoke API operations for your API Gateway deployment. For further details, you can review controlling access to an API with IAM permissions documentation. Go the AWS Management Console, click Services then select IAM under Security, Identity, and Compliance. Choose Policies . Search for WildRydes to see the WildRydesAPI-StandardUserPolicy which was created by the Serverless Backed CloudFormation template. Click the WildRydesAPI-StandardUserPolicy policy name. Review the policy which was created by CloudFormation to authorize requests to your API Gateway deployment. This policy allows access to invoke any method on the /ride path for any API stage of your API gateway backend. For more details about authoring IAM policies for API Gateway, visit the controlling access to an API with IAM permissions documentation. Choose Roles . Search for WildRydes to find the two roles which were created by Cognito Identity Pools when you created the Identity Pool in module one. Should you not be able to find the roles here, you can alternatively go to the Cognito Federated Identities console, find the correct identity pool, then click Edit Identity Pool in the top-right corner to see the roles listed. Each identity pool has both an Unauthenticated user role and an Authenticated user role. Select the Auth* role for your authenticated users. If the full name of the role is hidden from view due to column width, you can hover over the partially visible name of the role to see the full name of the role as a tool tip. Choose Attach policies . Search for WildRydes and check the box next to the policy named WildRydesAPI-StandardUserAccess . Choose Attach policy . You should now see the WildRydesAPI-StandardUserAccess policy associated with your Cognito IAM auth role. Enable API Gateway authorization with AWS IAM In addition to using JSON Web Tokens (JWTs) for authentication, API Gateway can leverage AWS request signing and parse the request signature to determine the requesting user. In this step, you'll update your authorization type to IAM for your API which will then use AWS's Identity and Access Management (IAM) capabilities to authorize requests via IAM policies. In the Amazon API Gateway console, update the authorization type to AWS_IAM for the POST method on the /ride resource. Next, re-deploy the API to make your change take effect. In the AWS Management Console choose Services then select API Gateway under Networking and Content Delivery. Choose the API named WildRydes . Browse to Resources while within your Wild Rydes API in the API Gateway console. Select the POST method under the /ride resource path. Choose Method Request Choose the pencil icon next to Authorization to edit the setting. Select AWS_IAM from the list of authorization options presented. Save your selection by clicking the checkmark icon next to the drop down. Next, choose the Actions button at the top of the resources list. Choose Deploy API from the list of options presented. For deployment stage, select prod then click Deploy . You've now successfully deployed your new authentication integration to your API's production environment. Configure your app to authenticate API requests Now that you've deployed the new authorizer configuration to production, all API requests must be authenticated to be processed. Return to your Wild Rydes app, sign in at /signin if necessary, and attempt to request a ride. You should receive an Error finding unicorn . If you open the developer console, you will see that we received a HTTP 401 error, which means it was an unauthorized request. If at first your requests go through without any errors, try requesting a ride again in 30-60 seconds to allow time for the API Gateway changes to fully propagate. Go back to Cloud9 and open the /website/src/pages/MainApp.js files. Update your current getData method to the following method, which removes the Authorization header and adds debugging information to show us the request signature as requests are sent. The default behavior of the AWS Amplify library is the sign all requests with SigV4 signing when no authorization header is specified, so this will automatically sign all requests using this algorithm without extra development effort. Save your changes after making this update. async getData ( pin ) { Amplify . Logger . LOG_LEVEL = DEBUG ; const apiRequest = { body : { PickupLocation : { Longitude : pin . longitude , Latitude : pin . latitude } }, headers : { Content-Type : application/json } }; console . log ( API Request: , apiRequest ); return await API . post ( apiName , apiPath , apiRequest ); } Allow the application to refresh, sign-in again, and request a ride. The unicorn ride request should be fulfilled as before now. To see the full request headers which were sent, look at the developer console for an message which includes the API Request details, including the full signature and headers of the request. This message starts with POST /prod/ride then shows the headers of the request made. You may notice that there were both x-amz-date and x-amz-security-token headers sent among other headers. These two headers are part of the overall request signature, along with the Authorization header.","title":"Optional: API Gateway Authorization with AWS IAM"},{"location":"03-iam-auth/","text":"Module 3 Retrieving and using temporary AWS credentials Time : 15 minutes In this module, you will expand your Wild Rydes application by enabling a profile management and profile photo management capabilities. Amazon Cognito will be used to store your user's profile information and custom attributes whereas Amazon S3 will store your user's profile pictures, with a link to the photo only being stored in the user's profile directly. Architecture Building on Modules 1 and 2, this module will add photo storage and management via an Amazon S3 bucket. For AWS resource access from a web application, Amazon Cognito will issue not only JWTs as we saw earlier, but then also allow users to assume an IAM role from within the application. This AWS IAM role will then allow their application to securely connect to upload and download photos from S3 (though any other AWS API would also work with this capability). To secure access to the photo storage and bucket, you will leverage IAM policies for fine-grained control. Setup S3 bucket for use with AWS Amplify You will need to configure AWS Amplify to securely store profile images in an S3 bucket. To save time, the Serverless Backend CloudFormation template that created the serverless backend API for this workshop also created an S3 bucket for this purpose with the cross-origin resource sharing (CORS) settings already set. You just need to associate this bucket with your application's code. To do this you'll browse to your CloudFormation stack created in the earlier modules and find the name of the S3 bucket under Outputs. Once you have the name you'll modify your amplify-config.js file again and update the storage section with the bucket's name and region. Go the AWS Management Console, click Services then select CloudFormation under Management Tools. In the CloudFormation console, click on your Wild Rydes stack name, such as WildRydesBackend . Click on the Outputs tab. Copy your bucket name to your clipboard. It is the name shown under Value for the key called WildRydesProfilePicturesBucket . Next, return to your Cloud9 IDE and open the file /website/src/amplify-config.js . Fill in values for both the bucket name, which you just copied, as well as the region where your CloudFormation template was launched Your final structure for the storage configuration of amplify-config.js should look like the following. Storage: { bucket: wildrydes-profilepicturesbucket-1rmvuic97osxd , region: us-east-1 } Configure IAM permissions Though you could now attempt uploading photos via AWS Amplify, Amplify would use your Cognito Identity Pool roles that were created in module 1 which currently has no policies associated so you would not have access to the S3 bucket created. You need to next update our roles to have policies that grant access to our S3 photo bucket. Browse to the IAM console and find your Cognito Identity Pool's authenticated user role. Create an in-line policy on this role which provides for S3 bucket protected and private-level access per-user by leveraging IAM policy variables. Go the AWS Management Console, click Services then select IAM under Security, Identity, and Compliance. Choose Roles . Search for WildRydes to find the two roles which were created by Cognito Identity Pools when you created the Identity Pool in module one. Should you not be able to find the roles here, you can alternatively go to the Cognito Federated Identities console, find the correct identity pool, then click Edit Identity Pool in the top-right corner to see the roles listed. Each identity pool has both an Unauthenticated user role and an Authenticated user role. Select the Auth* role for your authenticated users. We want to grant permissions to this role explicitly so we will use an inline policy, which would be deleted with this role if it were ever to be deleted. Choose Add inline policy on the right-hand side to create a new inline policy associated to this IAM role. Choose the JSON tab to allow you to free-form edit the new policy. Paste the following IAM policy statements for S3 access. After pasting, you will need to go replace the bucket name listed in all caps with your bucket name (a total of 4 times). Be sure to leave the parts of the resource names before and after the replacement value alone and not accidentally modify them. The following policy makes use of IAM policy variables where ${aws:userid} represents the current authenticated user's unique Cognito identity ID. This policy's effective permissions will allow all authenticated users to read objects from the root of the bucket and any /protected path, but only allow users to read their own private sub-path and write to their sub-path within the protected path. These are default paths that are integrated with AWS Amplify to easily set file access levels . { Version : 2012-10-17 , Statement : [ { Effect : Allow , Action : [ s3:PutObject , s3:GetObject , s3:GetObjectVersion , s3:DeleteObject , s3:DeleteObjectVersion ], Resource : arn:aws:s3:::REPLACE_WITH_YOUR_BUCKET_NAME/private/${aws:userid}/* }, { Effect : Allow , Action : [ s3:GetObject , s3:GetObjectVersion ], Resource : arn:aws:s3:::REPLACE_WITH_YOUR_BUCKET_NAME/protected/* }, { Effect : Allow , Action : [ s3:PutObject , s3:DeleteObject , s3:DeleteObjectVersion ], Resource : arn:aws:s3:::REPLACE_WITH_YOUR_BUCKET_NAME/protected/${aws:userid}/* }, { Effect : Allow , Action : [ s3:PutObject , s3:GetObject , s3:GetObjectVersion , s3:DeleteObject , s3:DeleteObjectVersion ], Resource : arn:aws:s3:::REPLACE_WITH_YOUR_BUCKET_NAME/public/* } ] } Choose Review policy . Name the policy WildRydes-S3Access . After reviewing for accuracy and any syntax errors, choose Create policy . Update application to upload photos Now that your IAM policies and Amplify SDK are initialized, you will be able to upload photos and render S3 photos with minimal code using Amplify's built-in UI components. S3 image is the component used to both render image objects for a React application, as well as embeding an image picker to help with uploads. Authenticate in the Wild Rydes app if you're not already logged in, then browse to the /profile path. You will see that your Cognito User Pool attributes are being read dynamically by the system. Next, you will add an image picker from AWS Amplify to render a UI component for uploading and displaying photos stored in S3. These profile photos will be used to personalize the rider experience so unicorns know who to look for when picking up passengers. After logging in to Wild Rydes (if you're not authenticated already), browse to the /profile path. You should see that your e-mail address and phone number you registered with are displayed which are all of your currently populated attributes. Open your Cloud9 IDE environment and open the file at /website/src/pages/Profile.js . Uncomment the line that says S3Image . This instantiates an Amplify UI component for React apps for image rendering and uploading and only requires this single line of code. Go back to the Wild Rydes app and visit the /profile path after logging in. You should now be able to upload photos with the new image picker. Store profile picture links in Cognito User Pools profile With our image uploads now working, all will work as expected until you close your browser, but at that point the reference between your user profile and your profile picture will be lost. To fix this, you will leverage a Cognito User Pools user attribute called picture to persist the S3 object key so the same image can be loaded upon each login and persisted to be shown to the unicorns when you request a ride. You will need to update /website/src/pages/Profile.js and a method called onImageLoad to make this possible. Implement a method to persist the images uploaded to the current user's Cognito picture attribute each time the image is changed. Open your Cloud9 IDE environment and open the file at /website/src/pages/Profile.js . The S3Image UI component has a built-in method called onImageLoad which provides in its invocation the full URL of any image uploaded. We will make use of this built-in function to persist our image URLs out to Cognito. Replace the existing onImageLoad function with the following code: async onImageLoad ( url ) { if (!this.state.user.getSession) { return } ; console . log ( Profile Picture URL: , url ); try { let result = await Auth.updateUserAttributes(this.state.user, { picture : this.state.image_key } ); console . log ( result ); } catch ( ex ) { console.error( Attribute update error : , ex ); } } Now with this new method in place, upload a new photo after logging into Wild Rydes then close your browser. Open a new window and try logging in again. Your photo should load as it did previously. Conclusion Congratulations! You've completed the Wild Rydes Auth workshop. We hope that this time and interactive learning has been valuable for you. This workshop was an adaptation of an existing workshop located in the aws-serverless-workshops repo . Please proceed to the next module to run through the clean up steps to ensure you decommission all resources spun up during the workshop today. Thank you for participating in this workshop!","title":"Module 3: Temporary AWS credentials"},{"location":"03-iam-auth/#module-3-retrieving-and-using-temporary-aws-credentials","text":"Time : 15 minutes In this module, you will expand your Wild Rydes application by enabling a profile management and profile photo management capabilities. Amazon Cognito will be used to store your user's profile information and custom attributes whereas Amazon S3 will store your user's profile pictures, with a link to the photo only being stored in the user's profile directly.","title":"Module 3 Retrieving and using temporary AWS credentials"},{"location":"03-iam-auth/#architecture","text":"Building on Modules 1 and 2, this module will add photo storage and management via an Amazon S3 bucket. For AWS resource access from a web application, Amazon Cognito will issue not only JWTs as we saw earlier, but then also allow users to assume an IAM role from within the application. This AWS IAM role will then allow their application to securely connect to upload and download photos from S3 (though any other AWS API would also work with this capability). To secure access to the photo storage and bucket, you will leverage IAM policies for fine-grained control.","title":"Architecture"},{"location":"03-iam-auth/#setup-s3-bucket-for-use-with-aws-amplify","text":"You will need to configure AWS Amplify to securely store profile images in an S3 bucket. To save time, the Serverless Backend CloudFormation template that created the serverless backend API for this workshop also created an S3 bucket for this purpose with the cross-origin resource sharing (CORS) settings already set. You just need to associate this bucket with your application's code. To do this you'll browse to your CloudFormation stack created in the earlier modules and find the name of the S3 bucket under Outputs. Once you have the name you'll modify your amplify-config.js file again and update the storage section with the bucket's name and region. Go the AWS Management Console, click Services then select CloudFormation under Management Tools. In the CloudFormation console, click on your Wild Rydes stack name, such as WildRydesBackend . Click on the Outputs tab. Copy your bucket name to your clipboard. It is the name shown under Value for the key called WildRydesProfilePicturesBucket . Next, return to your Cloud9 IDE and open the file /website/src/amplify-config.js . Fill in values for both the bucket name, which you just copied, as well as the region where your CloudFormation template was launched Your final structure for the storage configuration of amplify-config.js should look like the following. Storage: { bucket: wildrydes-profilepicturesbucket-1rmvuic97osxd , region: us-east-1 }","title":"Setup S3 bucket for use with AWS Amplify"},{"location":"03-iam-auth/#configure-iam-permissions","text":"Though you could now attempt uploading photos via AWS Amplify, Amplify would use your Cognito Identity Pool roles that were created in module 1 which currently has no policies associated so you would not have access to the S3 bucket created. You need to next update our roles to have policies that grant access to our S3 photo bucket. Browse to the IAM console and find your Cognito Identity Pool's authenticated user role. Create an in-line policy on this role which provides for S3 bucket protected and private-level access per-user by leveraging IAM policy variables. Go the AWS Management Console, click Services then select IAM under Security, Identity, and Compliance. Choose Roles . Search for WildRydes to find the two roles which were created by Cognito Identity Pools when you created the Identity Pool in module one. Should you not be able to find the roles here, you can alternatively go to the Cognito Federated Identities console, find the correct identity pool, then click Edit Identity Pool in the top-right corner to see the roles listed. Each identity pool has both an Unauthenticated user role and an Authenticated user role. Select the Auth* role for your authenticated users. We want to grant permissions to this role explicitly so we will use an inline policy, which would be deleted with this role if it were ever to be deleted. Choose Add inline policy on the right-hand side to create a new inline policy associated to this IAM role. Choose the JSON tab to allow you to free-form edit the new policy. Paste the following IAM policy statements for S3 access. After pasting, you will need to go replace the bucket name listed in all caps with your bucket name (a total of 4 times). Be sure to leave the parts of the resource names before and after the replacement value alone and not accidentally modify them. The following policy makes use of IAM policy variables where ${aws:userid} represents the current authenticated user's unique Cognito identity ID. This policy's effective permissions will allow all authenticated users to read objects from the root of the bucket and any /protected path, but only allow users to read their own private sub-path and write to their sub-path within the protected path. These are default paths that are integrated with AWS Amplify to easily set file access levels . { Version : 2012-10-17 , Statement : [ { Effect : Allow , Action : [ s3:PutObject , s3:GetObject , s3:GetObjectVersion , s3:DeleteObject , s3:DeleteObjectVersion ], Resource : arn:aws:s3:::REPLACE_WITH_YOUR_BUCKET_NAME/private/${aws:userid}/* }, { Effect : Allow , Action : [ s3:GetObject , s3:GetObjectVersion ], Resource : arn:aws:s3:::REPLACE_WITH_YOUR_BUCKET_NAME/protected/* }, { Effect : Allow , Action : [ s3:PutObject , s3:DeleteObject , s3:DeleteObjectVersion ], Resource : arn:aws:s3:::REPLACE_WITH_YOUR_BUCKET_NAME/protected/${aws:userid}/* }, { Effect : Allow , Action : [ s3:PutObject , s3:GetObject , s3:GetObjectVersion , s3:DeleteObject , s3:DeleteObjectVersion ], Resource : arn:aws:s3:::REPLACE_WITH_YOUR_BUCKET_NAME/public/* } ] } Choose Review policy . Name the policy WildRydes-S3Access . After reviewing for accuracy and any syntax errors, choose Create policy .","title":"Configure IAM permissions"},{"location":"03-iam-auth/#update-application-to-upload-photos","text":"Now that your IAM policies and Amplify SDK are initialized, you will be able to upload photos and render S3 photos with minimal code using Amplify's built-in UI components. S3 image is the component used to both render image objects for a React application, as well as embeding an image picker to help with uploads. Authenticate in the Wild Rydes app if you're not already logged in, then browse to the /profile path. You will see that your Cognito User Pool attributes are being read dynamically by the system. Next, you will add an image picker from AWS Amplify to render a UI component for uploading and displaying photos stored in S3. These profile photos will be used to personalize the rider experience so unicorns know who to look for when picking up passengers. After logging in to Wild Rydes (if you're not authenticated already), browse to the /profile path. You should see that your e-mail address and phone number you registered with are displayed which are all of your currently populated attributes. Open your Cloud9 IDE environment and open the file at /website/src/pages/Profile.js . Uncomment the line that says S3Image . This instantiates an Amplify UI component for React apps for image rendering and uploading and only requires this single line of code. Go back to the Wild Rydes app and visit the /profile path after logging in. You should now be able to upload photos with the new image picker.","title":"Update application to upload photos"},{"location":"03-iam-auth/#store-profile-picture-links-in-cognito-user-pools-profile","text":"With our image uploads now working, all will work as expected until you close your browser, but at that point the reference between your user profile and your profile picture will be lost. To fix this, you will leverage a Cognito User Pools user attribute called picture to persist the S3 object key so the same image can be loaded upon each login and persisted to be shown to the unicorns when you request a ride. You will need to update /website/src/pages/Profile.js and a method called onImageLoad to make this possible. Implement a method to persist the images uploaded to the current user's Cognito picture attribute each time the image is changed. Open your Cloud9 IDE environment and open the file at /website/src/pages/Profile.js . The S3Image UI component has a built-in method called onImageLoad which provides in its invocation the full URL of any image uploaded. We will make use of this built-in function to persist our image URLs out to Cognito. Replace the existing onImageLoad function with the following code: async onImageLoad ( url ) { if (!this.state.user.getSession) { return } ; console . log ( Profile Picture URL: , url ); try { let result = await Auth.updateUserAttributes(this.state.user, { picture : this.state.image_key } ); console . log ( result ); } catch ( ex ) { console.error( Attribute update error : , ex ); } } Now with this new method in place, upload a new photo after logging into Wild Rydes then close your browser. Open a new window and try logging in again. Your photo should load as it did previously.","title":"Store profile picture links in Cognito User Pools profile"},{"location":"03-iam-auth/#conclusion","text":"Congratulations! You've completed the Wild Rydes Auth workshop. We hope that this time and interactive learning has been valuable for you. This workshop was an adaptation of an existing workshop located in the aws-serverless-workshops repo . Please proceed to the next module to run through the clean up steps to ensure you decommission all resources spun up during the workshop today. Thank you for participating in this workshop!","title":"Conclusion"},{"location":"04-clean-up/","text":"Module 4: Clean up If you are doing this workshop as part of an AWS sponsored event where Event Engine is being used, you can SKIP clean up. The Event Engine system will take care of the clean up. To prevent your account from accruing additional charges, you should remove any resources that are no longer needed. Empty and delete the S3 Bucket First, you need to empty the S3 bucket that was created by the Serverless Backend CloudFormation template. From your Cloud9 developer environment run the following: aws s3 rb s3://MY-BUCKET-NAME --force Copy and paste your Bucket name from your scratch pad. Remove the Cognito Resources From your Cloud9 developer environment run the following: aws cognito-identity delete-identity-pool --identity-pool-id YOUR-IDENTITY-POOL-ID-HERE Copy and paste your Cognito identity pool ID from your scratch pad (example: us-west-2:b4b755cd-d359-42a1-9b49-f0e73f5b2571). Next, run the following command to delete the Cognito User Pool you created: aws cognito-idp delete-user-pool --user-pool-id YOUR-USER-POOL-ID-HERE Copy and paste your user pool ID from your scratch pad (example: us-west-2:us-west-2_srLwFQiEC). Detach IAM Policy Before you delete the backend stack, you will need to remove the IAM Policy that you manually attached to the Auth role. Navigate to the Identity and Access Management (IAM) Console and search for the Auth role and click into it. On the Role Summary page, find the policy named WildRydesAPI-StandardUserPolicy in the Permissions tab. Once you locate the policy, click the X to remove this policy from the IAM Role. A popup window will ask you to confirm that you want to remove it - click the red Detach button. Remove WildRydes Backend Next, you will need to remove the CloudFormation stack for the API. This stack should be named serverless-idm-backend . Once again, from the your terminal window, run: aws cloudformation delete-stack --stack-name serverless-idm-backend If you changed the name of your stack from the default, you will need to update the stack name to what you changed it to. If you clicked the quick link in the instructions, no adjustment to the above command is needed. You can run aws cloudformation describe-stacks to find the your stack name. Remove Cloud9 and VPC Stack Lastly, you will need to remove the CloudFormation Stack for the Cloud9 instance and the its VPC. This stack should be named serverless-idm-cloud9 . Deleting this stack will shut down and permanently delete your Cloud9 environment and all code or projects within so be sure you want to proceed before executing this command. aws cloudformation delete-stack --stack-name serverless-idm-cloud9 If you changed the name of your stack from the default, you will need to update the stack name to what you changed it to. If you clicked the quick link in the instructions, no adjustment to the command above is needed. You can run aws cloudformation describe-stacks to find your stack name. Finished! Congratulations on completing this workshop! This is the workshop's permanent home, so feel free to revisit as often as you'd like.","title":"Module 4: Clean up"},{"location":"04-clean-up/#module-4-clean-up","text":"If you are doing this workshop as part of an AWS sponsored event where Event Engine is being used, you can SKIP clean up. The Event Engine system will take care of the clean up. To prevent your account from accruing additional charges, you should remove any resources that are no longer needed.","title":"Module 4: Clean up"},{"location":"04-clean-up/#empty-and-delete-the-s3-bucket","text":"First, you need to empty the S3 bucket that was created by the Serverless Backend CloudFormation template. From your Cloud9 developer environment run the following: aws s3 rb s3://MY-BUCKET-NAME --force Copy and paste your Bucket name from your scratch pad.","title":"Empty and delete the S3 Bucket"},{"location":"04-clean-up/#remove-the-cognito-resources","text":"From your Cloud9 developer environment run the following: aws cognito-identity delete-identity-pool --identity-pool-id YOUR-IDENTITY-POOL-ID-HERE Copy and paste your Cognito identity pool ID from your scratch pad (example: us-west-2:b4b755cd-d359-42a1-9b49-f0e73f5b2571). Next, run the following command to delete the Cognito User Pool you created: aws cognito-idp delete-user-pool --user-pool-id YOUR-USER-POOL-ID-HERE Copy and paste your user pool ID from your scratch pad (example: us-west-2:us-west-2_srLwFQiEC).","title":"Remove the Cognito Resources"},{"location":"04-clean-up/#detach-iam-policy","text":"Before you delete the backend stack, you will need to remove the IAM Policy that you manually attached to the Auth role. Navigate to the Identity and Access Management (IAM) Console and search for the Auth role and click into it. On the Role Summary page, find the policy named WildRydesAPI-StandardUserPolicy in the Permissions tab. Once you locate the policy, click the X to remove this policy from the IAM Role. A popup window will ask you to confirm that you want to remove it - click the red Detach button.","title":"Detach IAM Policy"},{"location":"04-clean-up/#remove-wildrydes-backend","text":"Next, you will need to remove the CloudFormation stack for the API. This stack should be named serverless-idm-backend . Once again, from the your terminal window, run: aws cloudformation delete-stack --stack-name serverless-idm-backend If you changed the name of your stack from the default, you will need to update the stack name to what you changed it to. If you clicked the quick link in the instructions, no adjustment to the above command is needed. You can run aws cloudformation describe-stacks to find the your stack name.","title":"Remove WildRydes Backend"},{"location":"04-clean-up/#remove-cloud9-and-vpc-stack","text":"Lastly, you will need to remove the CloudFormation Stack for the Cloud9 instance and the its VPC. This stack should be named serverless-idm-cloud9 . Deleting this stack will shut down and permanently delete your Cloud9 environment and all code or projects within so be sure you want to proceed before executing this command. aws cloudformation delete-stack --stack-name serverless-idm-cloud9 If you changed the name of your stack from the default, you will need to update the stack name to what you changed it to. If you clicked the quick link in the instructions, no adjustment to the command above is needed. You can run aws cloudformation describe-stacks to find your stack name.","title":"Remove Cloud9 and VPC Stack"},{"location":"04-clean-up/#finished","text":"Congratulations on completing this workshop! This is the workshop's permanent home, so feel free to revisit as often as you'd like.","title":"Finished!"},{"location":"contribute/","text":"Contributing Guidelines Thank you for your interest in contributing to our project. Whether it's a bug report, new feature, correction, or additional documentation, we greatly value feedback and contributions from our community. Please read through this document before submitting any issues or pull requests to ensure we have all the necessary information to effectively respond to your bug report or contribution. Reporting Bugs/Feature Requests We welcome you to use the GitHub issue tracker to report bugs or suggest features. When filing an issue, please check existing open , or recently closed , issues to make sure somebody else hasn't already reported the issue. Please try to include as much information as you can. Details like these are incredibly useful: A reproducible test case or series of steps The version of our code being used Any modifications you've made relevant to the bug Anything unusual about your environment or deployment Contributing via Pull Requests Contributions via pull requests are much appreciated. Before sending us a pull request, please ensure that: You are working against the latest source on the master branch. You check existing open, and recently merged, pull requests to make sure someone else hasn't addressed the problem already. You open an issue to discuss any significant work - we would hate for your time to be wasted. To send us a pull request, please: Fork the repository. Modify the source; please focus on the specific change you are contributing. If you also reformat all the code, it will be hard for us to focus on your change. Ensure local tests pass. Commit to your fork using clear commit messages. Send us a pull request, answering any default questions in the pull request interface. Pay attention to any automated CI failures reported in the pull request, and stay involved in the conversation. GitHub provides additional document on forking a repository and creating a pull request . Finding contributions to work on Looking at the existing issues is a great way to find something to contribute on. As our projects, by default, use the default GitHub issue labels ((enhancement/bug/duplicate/help wanted/invalid/question/wontfix), looking at any 'help wanted' issues is a great place to start. Code of Conduct This project has adopted the Amazon Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opensource-codeofconduct@amazon.com with any additional questions or comments. Security issue notifications If you discover a potential security issue in this project we ask that you notify AWS/Amazon Security via our vulnerability reporting page . Please do not create a public github issue. Licensing See the LICENSE file for our project's licensing. We will ask you to confirm the licensing of your contribution. We may ask you to sign a Contributor License Agreement (CLA) for larger changes.","title":"Contributing"},{"location":"contribute/#contributing-guidelines","text":"Thank you for your interest in contributing to our project. Whether it's a bug report, new feature, correction, or additional documentation, we greatly value feedback and contributions from our community. Please read through this document before submitting any issues or pull requests to ensure we have all the necessary information to effectively respond to your bug report or contribution.","title":"Contributing Guidelines"},{"location":"contribute/#reporting-bugsfeature-requests","text":"We welcome you to use the GitHub issue tracker to report bugs or suggest features. When filing an issue, please check existing open , or recently closed , issues to make sure somebody else hasn't already reported the issue. Please try to include as much information as you can. Details like these are incredibly useful: A reproducible test case or series of steps The version of our code being used Any modifications you've made relevant to the bug Anything unusual about your environment or deployment","title":"Reporting Bugs/Feature Requests"},{"location":"contribute/#contributing-via-pull-requests","text":"Contributions via pull requests are much appreciated. Before sending us a pull request, please ensure that: You are working against the latest source on the master branch. You check existing open, and recently merged, pull requests to make sure someone else hasn't addressed the problem already. You open an issue to discuss any significant work - we would hate for your time to be wasted. To send us a pull request, please: Fork the repository. Modify the source; please focus on the specific change you are contributing. If you also reformat all the code, it will be hard for us to focus on your change. Ensure local tests pass. Commit to your fork using clear commit messages. Send us a pull request, answering any default questions in the pull request interface. Pay attention to any automated CI failures reported in the pull request, and stay involved in the conversation. GitHub provides additional document on forking a repository and creating a pull request .","title":"Contributing via Pull Requests"},{"location":"contribute/#finding-contributions-to-work-on","text":"Looking at the existing issues is a great way to find something to contribute on. As our projects, by default, use the default GitHub issue labels ((enhancement/bug/duplicate/help wanted/invalid/question/wontfix), looking at any 'help wanted' issues is a great place to start.","title":"Finding contributions to work on"},{"location":"contribute/#code-of-conduct","text":"This project has adopted the Amazon Open Source Code of Conduct . For more information see the Code of Conduct FAQ or contact opensource-codeofconduct@amazon.com with any additional questions or comments.","title":"Code of Conduct"},{"location":"contribute/#security-issue-notifications","text":"If you discover a potential security issue in this project we ask that you notify AWS/Amazon Security via our vulnerability reporting page . Please do not create a public github issue.","title":"Security issue notifications"},{"location":"contribute/#licensing","text":"See the LICENSE file for our project's licensing. We will ask you to confirm the licensing of your contribution. We may ask you to sign a Contributor License Agreement (CLA) for larger changes.","title":"Licensing"},{"location":"license/","text":"License MIT License Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"}]}